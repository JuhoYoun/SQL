데이터 특성 분석
* SELECT COUNT(email) FROM copang_main.member; -> Count the number of rows that have email value (if a row has Null email vlaue, Count() function does not count the row) -> Count(email) 이라는 새로운 칼럼이 생기고 로우 개수를 보여준다
* SELECT COUNT(*) FROM copang_main.member; -> 이 SELECT 문에 의해 리턴되는 전체 로우값을 보여준다 -> 어떤 칼럼 값들의 Null 여부와 상관 없이 테이블의 전체 로우 개수를 보고 싶을 때 사용한다
* SELECT MAX(height) FROM copang_main.member; -> MAX() function은 최대 height 값을 보여준다
* SELECT MIN(height) FROM copang_main.member; -> MIN() function은 최소 height 값을 보여준다
* SELECT AVG(height) FROM copang_main.member; -> AVG() function은 평균 height 값을 보여준다 단, Null 값들은 빼고 평균을 구한다
* SELECT MAX(height), email FROM copang_main.member; -> error
* SELECT MAX(height) email FROM copang_main.member; -> 최대 height 값의 칼럼 레이블명이 email로 바뀐다

-------------------------------------------------------------------------------------------------------------------------------------------------

이전 영상에서는 한 컬럼의 

개수(COUNT)

최댓값(MAX)

최솟값(MIN)

평균값(AVG)

을 구하는 함수들을 배웠습니다. 이 함수들처럼 어떤 컬럼의 값들을 대상으로 원하는 특징값을 구해주는 함수를 Aggregate Function, 우리말로는 집계 함수라고 합니다. 집계 함수에는 이전 영상에서 배운 것 말고도 

모든 값의 합을 구하는 SUM 함수, 

모든 값의 표준편차를 구하는 STD 함수 등이 있습니다. 각각 다음과 같습니다.
1. SUM 함수 - 합계

2. STD 함수 - 표준편차

그런데 SQL에는 집계 함수 말고도, 단순한 산술 연산을 해주는 Mathematical Function들도 있습니다. 우리 말로 '산술 함수'라고 할 수 있는데요. 산술 함수에는 다음과 같은 것들이 있습니다.

ABS 함수 - 절대값을 구하는 함수

SQRT 함수 - 제곱근을 구하는 함수 

CEIL 함수 - 올림 함수

3. FLOOR 함수 - 내림 함수

4. ROUND 함수 - 반올림 함수

이것 말고도 또 다양한 산술 함수들이 있는데요. 그밖의 다양한 산술 함수들이 궁금하신 분들은 이 링크를 참조하세요.  https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html

그렇다면 집계 함수와 산술 함수는 정확히 어떤 차이점이 있을까요? 둘의 차이점은

(1) 집계 함수는 특정 컬럼의 여러 row의 값들을 동시에 고려해서 실행되는 함수이고

(2) 산술 함수는 특정 컬럼의 각 row의 값마다 실행되는 함수

라는 점입니다.

예를 들어 집계 함수인 MAX 함수를 생각해보세요. 특정 컬럼의 값 중에서 최댓값을 구하려면 당연히 여러 row의 값들을 동시에 고려해야겠죠?

하지만 ABS, ROUND 같은 산술 함수들은 그렇지 않습니다. 이 함수들은 그냥 특정 컬럼의 각 row의 값들에 대해 각각 실행될 뿐입니다.

이 둘이 어떤 차이가 있는지 잘 아시겠죠? 데이터 분석을 할 때 숫자값을 자유롭게 다루려면 이 집계 함수와 산술 함수를 많이 알면 알수록 좋습니다. 특히 이번 토픽에서 배운 함수들을 잘 익혀둔다면 도움이 되겠죠? 
----------------------------------------------------------------------------------------------------------------------------------------------------

NULL 다루기
* SELECT * FROM copang_main.member WHERE height IS NULL; -> height 이 NULL인 로우만 출력
* SELECT * FROM copang_main.member WHERE height IS NOT NULL; -> height이 NULL이 아닌 로우만 출력
* SELECT * FROM copang_main.member WHERE height IS NULL OR age IS NULL OR weight IS NULL; -> OR문 같이 사용 예시
* SELECT COALESCE(height, '----'), COALESCE(weight, '@@@@'), COALESCE(address, '????') FROM copang_main.member; -> COALESCE function은 로우들을 차례로 조회하면서 해당 칼럼값의 값이 있다면 그대로 리턴하고 값이 없다면(NULL) COALESCE function의 두번째 input값을 리턴한다 -> 이 때 출력되는 테이블은  COALESCE(height, '----'), COALESCE(weight, '@@@@'), COALESCE(address, '????') 이렇게 세개의 칼럼값만 갖는다  
------------------------------------------------------------------------------------------------------------------------------------------------------

1. IS NULL 과 = NULL은 다릅니다.

간혹 IS NULL을 써야할 자리에 = NULL이라고 쓰는 실수를 하는 분들이 있습니다. 그러니까 이렇게 써야할 SQL 문을 

이렇게 써버리는 거죠.

이런 실수를 하면, 위 그림에서 보이는 것처럼 아무 row도 출력되지 않습니다. 

NULL은 어떤 값이 아니기 때문에 애초에 등호(=)를 사용해서 어떤 값과 비교할 수 있는 대상이 아닙니다. 그래서 = NULL은 절대 True일 수가 없죠. 그래서 IS NULL이라는 키워드가 별도로 마련된 겁니다. 앞으로 NULL인지를 확인할 때는 = NULL을 쓰면 안 되고, 반드시 IS NULL을 써야한다는 점을 꼭 기억하셔야 합니다.

그럼 당연히 != NULL, <> NULL 같은 것도 쓸 수 없겠죠? 이 표현은 이전 영상에서 배운대로 IS NOT NULL이라고 나타내야 하는 겁니다. 

이 부분은 NULL을 처음 배우는 분들히 흔히들 하는 실수니까 주의하세요.
2. NULL에는 어떤 연산을 해도 결국 NULL이다.

잠깐 member 테이블 전체를 조회해볼게요. 

cowboy@codeit.kr이라는 회원의 height 컬럼에 NULL이 들어있죠? 만약 height 컬럼에 +3을 해서 조회한다면 이 NULL은 어떻게 보일까요?

가장 오른쪽을 보면, 각 row의 height 컬럼의 값에 3을 더한 값이 담긴 새 컬럼이 추가돼서 보이네요. 그런데 지금 가장 오른쪽의 빨간색 박스를 보면 원래 height 컬럼이 NULL이었던 곳은 여전히 NULL인 것을 알 수 있는데요.

사실 NULL에는 뭘 더하든, 빼든, 곱하든, 나누든지 간에 항상 NULL입니다. NULL이라는 것 자체가 값이 없음을 나타내는데 그것에 어떤 처리를 해봤자 결국 또 NULL일 수밖에 없는 거죠. 오히려 어떤 값이 도출되는 게 더 이상하겠죠? 이 사실은 곧 다른 영상에서도 다시 등장하니까 잘 기억하세요. 
--------------------------------------------------------------------------------------------------------------------------------------------------------

이상한 값들을 제외하고 싶다면?
* SELECT AVE(age) FROM copang_main.member WHERE age BETWEEN 5 AND 100; -> 이러면 300이나 -10 같이 유저가 아무렇게나 입력한 값들을 필터링할 수 있다
* SELECT * FROM copang_main.member WHERE address NOT LIKE '%호'; -> 보통 주소는 ~도 ~시 ~동 ~호 이렇게 구성되기 때문에 다음의 명령어로 ~호로 끝나지 않는 주소값을 가진 유저들을 추려낸 후 제대로된 주소값을 요구할 수 있다
* SELECT * FROM copang_main.member WHERE address LIKE '%호'; -> 제대로된 주소들만 필터링
