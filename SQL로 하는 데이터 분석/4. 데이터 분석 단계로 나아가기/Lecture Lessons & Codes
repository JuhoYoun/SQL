데이터 특성 분석
* SELECT COUNT(email) FROM copang_main.member; -> Count the number of rows that have email value (if a row has Null email vlaue, Count() function does not count the row) -> Count(email) 이라는 새로운 칼럼이 생기고 로우 개수를 보여준다
* SELECT COUNT(*) FROM copang_main.member; -> 이 SELECT 문에 의해 리턴되는 전체 로우값을 보여준다 -> 어떤 칼럼 값들의 Null 여부와 상관 없이 테이블의 전체 로우 개수를 보고 싶을 때 사용한다
* SELECT MAX(height) FROM copang_main.member; -> MAX() function은 최대 height 값을 보여준다
* SELECT MIN(height) FROM copang_main.member; -> MIN() function은 최소 height 값을 보여준다
* SELECT AVG(height) FROM copang_main.member; -> AVG() function은 평균 height 값을 보여준다 단, Null 값들은 빼고 평균을 구한다
* SELECT MAX(height), email FROM copang_main.member; -> error
* SELECT MAX(height) email FROM copang_main.member; -> 최대 height 값의 칼럼 레이블명이 email로 바뀐다

-------------------------------------------------------------------------------------------------------------------------------------------------

이전 영상에서는 한 컬럼의 

개수(COUNT)

최댓값(MAX)

최솟값(MIN)

평균값(AVG)

을 구하는 함수들을 배웠습니다. 이 함수들처럼 어떤 컬럼의 값들을 대상으로 원하는 특징값을 구해주는 함수를 Aggregate Function, 우리말로는 집계 함수라고 합니다. 집계 함수에는 이전 영상에서 배운 것 말고도 

모든 값의 합을 구하는 SUM 함수, 

모든 값의 표준편차를 구하는 STD 함수 등이 있습니다. 각각 다음과 같습니다.
1. SUM 함수 - 합계

2. STD 함수 - 표준편차

그런데 SQL에는 집계 함수 말고도, 단순한 산술 연산을 해주는 Mathematical Function들도 있습니다. 우리 말로 '산술 함수'라고 할 수 있는데요. 산술 함수에는 다음과 같은 것들이 있습니다.

ABS 함수 - 절대값을 구하는 함수

SQRT 함수 - 제곱근을 구하는 함수 

CEIL 함수 - 올림 함수

3. FLOOR 함수 - 내림 함수

4. ROUND 함수 - 반올림 함수

이것 말고도 또 다양한 산술 함수들이 있는데요. 그밖의 다양한 산술 함수들이 궁금하신 분들은 이 링크를 참조하세요.  https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html

그렇다면 집계 함수와 산술 함수는 정확히 어떤 차이점이 있을까요? 둘의 차이점은

(1) 집계 함수는 특정 컬럼의 여러 row의 값들을 동시에 고려해서 실행되는 함수이고

(2) 산술 함수는 특정 컬럼의 각 row의 값마다 실행되는 함수

라는 점입니다.

예를 들어 집계 함수인 MAX 함수를 생각해보세요. 특정 컬럼의 값 중에서 최댓값을 구하려면 당연히 여러 row의 값들을 동시에 고려해야겠죠?

하지만 ABS, ROUND 같은 산술 함수들은 그렇지 않습니다. 이 함수들은 그냥 특정 컬럼의 각 row의 값들에 대해 각각 실행될 뿐입니다.

이 둘이 어떤 차이가 있는지 잘 아시겠죠? 데이터 분석을 할 때 숫자값을 자유롭게 다루려면 이 집계 함수와 산술 함수를 많이 알면 알수록 좋습니다. 특히 이번 토픽에서 배운 함수들을 잘 익혀둔다면 도움이 되겠죠? 
----------------------------------------------------------------------------------------------------------------------------------------------------

NULL 다루기
* SELECT * FROM copang_main.member WHERE height IS NULL; -> height 이 NULL인 로우만 출력
* SELECT * FROM copang_main.member WHERE height IS NOT NULL; -> height이 NULL이 아닌 로우만 출력
* SELECT * FROM copang_main.member WHERE height IS NULL OR age IS NULL OR weight IS NULL; -> OR문 같이 사용 예시
* SELECT COALESCE(height, '----'), COALESCE(weight, '@@@@'), COALESCE(address, '????') FROM copang_main.member; -> COALESCE function은 로우들을 차례로 조회하면서 해당 칼럼값의 값이 있다면 그대로 리턴하고 값이 없다면(NULL) COALESCE function의 두번째 input값을 리턴한다 -> 이 때 출력되는 테이블은  COALESCE(height, '----'), COALESCE(weight, '@@@@'), COALESCE(address, '????') 이렇게 세개의 칼럼값만 갖는다  
------------------------------------------------------------------------------------------------------------------------------------------------------

1. IS NULL 과 = NULL은 다릅니다.

간혹 IS NULL을 써야할 자리에 = NULL이라고 쓰는 실수를 하는 분들이 있습니다. 그러니까 이렇게 써야할 SQL 문을 

이렇게 써버리는 거죠.

이런 실수를 하면, 위 그림에서 보이는 것처럼 아무 row도 출력되지 않습니다. 

NULL은 어떤 값이 아니기 때문에 애초에 등호(=)를 사용해서 어떤 값과 비교할 수 있는 대상이 아닙니다. 그래서 = NULL은 절대 True일 수가 없죠. 그래서 IS NULL이라는 키워드가 별도로 마련된 겁니다. 앞으로 NULL인지를 확인할 때는 = NULL을 쓰면 안 되고, 반드시 IS NULL을 써야한다는 점을 꼭 기억하셔야 합니다.

그럼 당연히 != NULL, <> NULL 같은 것도 쓸 수 없겠죠? 이 표현은 이전 영상에서 배운대로 IS NOT NULL이라고 나타내야 하는 겁니다. 

이 부분은 NULL을 처음 배우는 분들히 흔히들 하는 실수니까 주의하세요.
2. NULL에는 어떤 연산을 해도 결국 NULL이다.

잠깐 member 테이블 전체를 조회해볼게요. 

cowboy@codeit.kr이라는 회원의 height 컬럼에 NULL이 들어있죠? 만약 height 컬럼에 +3을 해서 조회한다면 이 NULL은 어떻게 보일까요?

가장 오른쪽을 보면, 각 row의 height 컬럼의 값에 3을 더한 값이 담긴 새 컬럼이 추가돼서 보이네요. 그런데 지금 가장 오른쪽의 빨간색 박스를 보면 원래 height 컬럼이 NULL이었던 곳은 여전히 NULL인 것을 알 수 있는데요.

사실 NULL에는 뭘 더하든, 빼든, 곱하든, 나누든지 간에 항상 NULL입니다. NULL이라는 것 자체가 값이 없음을 나타내는데 그것에 어떤 처리를 해봤자 결국 또 NULL일 수밖에 없는 거죠. 오히려 어떤 값이 도출되는 게 더 이상하겠죠? 이 사실은 곧 다른 영상에서도 다시 등장하니까 잘 기억하세요. 
--------------------------------------------------------------------------------------------------------------------------------------------------------

이상한 값들을 제외하고 싶다면?
* SELECT AVE(age) FROM copang_main.member WHERE age BETWEEN 5 AND 100; -> 이러면 300이나 -10 같이 유저가 아무렇게나 입력한 값들을 필터링할 수 있다
* SELECT * FROM copang_main.member WHERE address NOT LIKE '%호'; -> 보통 주소는 ~도 ~시 ~동 ~호 이렇게 구성되기 때문에 다음의 명령어로 ~호로 끝나지 않는 주소값을 가진 유저들을 추려낸 후 제대로된 주소값을 요구할 수 있다
* SELECT * FROM copang_main.member WHERE address LIKE '%호'; -> 제대로된 주소들만 필터링
-----------------------------------------------------------------------------------------------------------------------------------------------------------
이전 영상들에서 우리는

(1) 컬럼의 값이 NULL이거나

(2) 아예 이상한 값인 경우들을

살펴봤습니다.

지금 여러분은 SQL을 배우는 단계이기 때문에, 코드잇에서 준비한 '학습용 데이터'를 사용하고 있는데요.

실제로는 이렇게 NULL이 있거나, 이상한 값이 있는 경우가 그렇게 많지는 않습니다. 

잠깐 어떤 서비스의 회원가입을 예로 들자면,

실제 서비스에서는

    사용자로부터 반드시 획득해야하는 정보에 대해서는, 사용자가 꼭 입력을 해야만 
    그리고 입력된 값이 유효해야만(예를 들어, 나이 값이라면 0 이상 100이하여야 한다는 조건 등)

회원가입이 승인되도록, 개발자들이 이미 프로그램 코드 상에서 방어를 해주기 때문입니다.

하지만 생긴 지 오래된 서비스이거나, 시간이 촉박한 상황에서 급하게 만들어져 꼼꼼하게 개발되지 않은 서비스인 경우에는 고객으로부터 수집된 데이터가 완벽하지 않을 수도 있습니다.

따라서 여러분 또한 불완전한 데이터(NULL, 이상한 값)를 가지고도 유의미한 인사이트(insight)를 도출할 수 있어야 합니다. 그리고 이전 영상들에서 배운 'NULL과 이상한 값을 적절하게 처리하는 방법'은 꼭 알아야하는 내용이구요. 

여러분이 회사에서 

    불완전한 데이터 속에서도 유의미한 인사이트를 끌어내고 동시에 
    더 완벽한 데이터 수집을 위한 피드백을 개발팀에 전달할 수 있게 된다면 

누구에게나 인정받는 사람이 될 수 있겠죠?
-----------------------------------------------------------------------------------------------------------------------------------------------
칼럼끼리 계산하기
* SELECT email, height, weight, weight / ((height / 100) * (height / 100)) FROM copang_main.member; -> BMI 계산식을 그대로 넣어서 칼럼끼리 계산한 BMI 칼럼도 같이 출력 가능
* weight 이나 height 중 하나라도 NULL이면 BMI값도 NULL로 출력됨
* 칼럼끼리 사용가능한 산술 연산 기호는 + - * / % 

ALIAS
* 칼럼에 ALIAS를 붙일 수 있다 
* SELECT email, height, weight, weight / ((height / 100) * (height / 100)) AS BMI FROM copang_main.member; -> BMI alias룰 붙인다
* SELECT email, height, weight, weight / ((height / 100) * (height / 100)) BMI FROM copang_main.member; -> AS를 안붙여도 alias를 붙일 수 있다 -> AS를 써서 가독성을 높여라

CANCAT
* Concatenate 연결하다
* SELECT CONCAT(height, 'cm', ', ', weight, 'kg') AS 'Height and Weight'; -> CONCAT function은 input 값들을 연결해 하나의 형태로 출력해준다

CASE / END
ex)
SELECT email, CONCAT(height, 'cm', ', ', weight, 'kg') AS 'Height and Weight', weight / ((height / 100) * (height / 100)) AS BMI,

CASE
    WHEN height IS NULL OR weight IS NULL THEN '비만 여부 알 수 없음'
    WHEN weight / ((height / 100) * (height / 100)) >= 25 THEN '과체중 또는 비만'
    WHEN weight / ((height / 100) * (height / 100)) >= 18.5 AND weight / ((height / 100) * (height / 100)) < 25 THEN '정상'
    ELSE '저체중'
END

FROM copang_main.member;

ex)
SELECT email, CONCAT(height, 'cm', ', ', weight, 'kg') AS 'Height and Weight', weight / ((height / 100) * (height / 100)) AS BMI,

(CASE
    WHEN height IS NULL OR weight IS NULL THEN '비만 여부 알 수 없음'
    WHEN weight / ((height / 100) * (height / 100)) >= 25 THEN '과체중 또는 비만'
    WHEN weight / ((height / 100) * (height / 100)) >= 18.5 AND weight / ((height / 100) * (height / 100)) < 25 THEN '정상'
    ELSE '저체중'
END) AS Obesity_Check

FROM copang_main.member;

ex)
SELECT email, CONCAT(height, 'cm', ', ', weight, 'kg') AS 'Height and Weight', weight / ((height / 100) * (height / 100)) AS BMI,

(CASE
    WHEN height IS NULL OR weight IS NULL THEN '비만 여부 알 수 없음'
    WHEN weight / ((height / 100) * (height / 100)) >= 25 THEN '과체중 또는 비만'
    WHEN weight / ((height / 100) * (height / 100)) >= 18.5 AND weight / ((height / 100) * (height / 100)) < 25 THEN '정상'
    ELSE '저체중'
END) AS Obesity_Check

FROM copang_main.member
ORDER BY Obesity_Check ASC;

* This case why?

SELECT email, CONCAT(height, 'cm', ', ', weight, 'kg') AS 'Height and Weight', weight / ((height / 100) * (height / 100)) AS BMI,

(CASE
    WHEN height IS NULL OR weight IS NULL THEN '비만 여부 알 수 없음'
    WHEN weight / ((height / 100) * (height / 100)) >= 25 THEN '과체중 또는 비만'
    WHEN weight / ((height / 100) * (height / 100)) >= 18.5 AND weight / ((height / 100) * (height / 100)) < 25 THEN '정상'
    ELSE '저체중'
END) AS 'Obesity Check'

FROM copang_main.member
ORDER BY 'Obesity Check' ASC;
-> 이 경우 정렬이 되지않음 왜?
