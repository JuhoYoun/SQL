이전 챕터까지 우리는 코드잇의 쇼핑몰 사이트인 '코팡'에서 쓰일 

    copang_main이라는 데이터베이스의
    member 테이블

을 갖고 SQL을 배웠습니다. 

하지만, 실전에서 여러분은 최소 열 개, 많으면 수 십, 수 백 개의 테이블을 다뤄야할 수도 있습니다. 게다가 이 때 테이블 하나씩을 별도로 다룰 수 있어야할 뿐만 아니라, 테이블 간의 연관 관계를 파악하고 여러 테이블을 하나로 합쳐서 볼 수 있어야 합니다.

여러 테이블을 합쳐서 하나의 테이블인 것처럼 보는 행위를 '조인(join)'이라고 하는데요. 실무에서는 이 조인을 잘해야 제대로된 데이터 분석을 할 수 있습니다. 조인은 그 사람이 SQL을 얼마나 잘 쓰는지 판단하는 척도 중 하나일만큼 정말 중요한 개념인데요.

조인이 구체적으로 무엇인지는 곧 다음 영상에서 설명하겠습니다. 일단 다음 노트의 내용을 따라해서 원래 있던 member 테이블 이외에 또다른 여러 테이블들을 추가하세요. 

참고로, 이번 챕터는 여러분이 이전 챕터들에서 배운 내용을 모두 완벽하게 이해했다고 가정하고 진행됩니다. 혹시 이전 챕터 내용들 중에서 아직 확실하게 이해하지 못한 내용이 있다면 다시 복습하고, 이 챕터를 들으시기 바랍니다. 
----------------------------------------------------------------------------------------------------------------------------------------------------------

이번 챕터에서 여러 테이블을 하나로 합치는 조인(join)을 배울 거라고 했죠? 그럼 일단 여러 테이블들이 있어야할 겁니다. 이번 챕터에서 사용할 테이블들을 생성해볼게요. 이전 노트에서 CSV 파일을 임포트해서 테이블을 생성한 적이 있었는데 기억나시나요? 해당 노트의 내용을 참조해서 여러분 스스로 아래의 CSV 파일 4개를 각각 테이블로 만들어보세요.

item-data.csv -> item 테이블

item-new-data.csv -> item_new 테이블

stock-data.csv -> stock 테이블

review-data.csv -> reivew 테이블

각 테이블에 대해 간단히 설명하자면 다음과 같습니다.

item 테이블 : '코팡'의 상품 정보

item_new 테이블 : (나중 영상에서 설명하겠습니다) 

stock 테이블 : '코팡'의 각 상품 재고 정보

review 테이블 : 고객들이 상품 구매 후 남긴 리뷰 정보

각 테이블은 다음 영상들에서도 등장하니까 그때 또 자세히 설명할게요.

4개의 테이블을 생성하고 나면,

각 테이블의

(1) id 컬럼을 Primary Key로 설정하고, Auto Increment 설정을 해주세요. 

(2) 그리고 날짜를 나타내는 컬럼이 있다면 그 컬럼의 데이터 타입을 DATE으로 변경해주세요.

아래 그림들처럼 말이죠. 
1. item 테이블

2. item_new 테이블(item 테이블과 컬럼 구조가 같은, 같은 종류의 테이블입니다.) 

3. stock 테이블 

4. review 테이블

그리고 각 테이블의 컬럼 속성을 수정하고 나서는 Apply 버튼을 누르는 것, 잊지 마세요! 4개의 테이블이 잘 생성된 분은 다음 영상으로 넘어가시면 됩니다.

*혹시 이렇게 해도 프로그램 에러 발생 등으로 인해 작업을 수행할 수 없는 경우에는, 아래 보이는 SQL 문들을 그대로 Workbench에 복사-붙여넣기해서 실행해주세요. 그럼 똑같은 테이블들이 생성됩니다.
-----------------------------------------------------------------------------------------------------------------------------------------------

*stock 테이블의 item_id 칼럼에는 item 테이블 id 칼럼값이 들어가야한다

Foreign Key / Parent Table / Child Table

이전 영상에서는 stock 테이블의 item_id 컬럼과 item 테이블의 id 컬럼이 갖는 관계를 설명했습니다. 

잠깐 stock 테이블에 있는 row를 하나 선택해볼까요?

row 하나를 선택해서 보면 재고 수(inventory_count)가 195개라는 걸 알 수 있습니다. 

그런데 어떤 상품의 재고수를 나타내는 건지 바로는 알 수 없습니다. 일단 item_id 컬럼의 값인 15를 보고,

item 테이블을 간 다음에 

이렇게 id 컬럼의 값이 15인 row를 찾으면 됩니다. 방금 재고 수 정보는 ‘자수 반팔 티셔츠’라는 상품의 재고 수였네요. 

지금 두 테이블 간의 관계를 한 문장으로 표현하면,

‘stock 테이블의 item_id 컬럼이 item 테이블의 id 컬럼을 참조하는 관계’

라고 할 수 있습니다. 

그리고 지금 item_id 컬럼처럼, '다른 테이블의 특정 row를 식별할 수 있게 해주는 컬럼'을 Foreign Key라고 합니다. 

Foreign Key는 우리말로 외래키라고도 합니다.

바로 이럴 때

(1) 참조를 하는 테이블인 stock 테이블을 ‘자식 테이블’

(2) 참조를 당하는 테이블인 item 테이블을 ‘부모 테이블’

이라고 합니다. 

아래 그림을 잠깐 볼까요?

이때까지 제가 설명한 내용이 한눈에 잘 보이는데요. 지금 자식 테이블의 Foreign Key가 부모 테이블의 Primary Key를 참조하고 있죠? Foreign Key는 다른 테이블의 특정 row를 식별할 수 있어야 하기 때문에 주로 다른 테이블의 Primary Key를 참조할 때가 많습니다. 

이제 Foreign Key가 뭔지 아시겠죠?
-------------------------------------------------------------------------------------------------------------------------------

*stock 테이블에서 item_id 를 item 테이블의 id 칼럼을 참조하는 (reference) foreign key 를 설정하면 item_id 칼럼에 부적절한 값(item 테이블의 id 칼럼에 있는 값 이외의 값)이 들어가는것을 막을 수 있다

Foreign Key 설정 방법
* stock 테이블의 컬럼들을 보는 창을 연다
* 창의 아랫부분에 foreign key 라고 써있는 탭을 연다
* foreign key 설정 자체의 이름을 지정해줘야한다 (Foreign key  /  Referenced Table 라고 되있는 탭창에서)
* Foriegn key 탭 아래에 이름을 지정해준다
* Referenced Table 탭에서 stock 테이블이 참조하는 테이블을 설정해준다
* 오른쪽의 Foreing key details '지정한 foreign key 설정 이름' 아래 Column / Refernced Colunm 에서 참조하는 / 참조되는 칼럼을 설정한다
* Column에 item_id, Referenced Colunm에 id 를 설정해준다
* Apply를 클릭해 설정을 마무리한다

Join
* 여러 테이블을 합쳐서 하나로 보이게 만든다

ex)
SELECT
    item.id
    item.name
    stock.item_id
    stock.inventory_count
FROM item LEFT OUTER JOIN stock
ON item.id = stock.item_id

* LEFT OUTER JOIN : 왼쪽에 있는 item 테이블 기준으로 해서 거기에 stock 테이블을 합치라는 뜻 -> 기준은 아래줄의 ON 에 지시되어 있다 -> item 테이블의 id 값과 stock 테이블의 item.id 값을 비교해서 서로 값이 같은 로우끼리 가로 방향으로 연결하라는 뜻
* SELECT 문 : item 테이블의 id와 name 칼럼과 stock 테이블의 item_id와 inventory_count 칼럼을 보여달라는 뜻
* 위의 sql문을 실행 시 item_id와 inventory_count에 Null이 있는 로우들도 포함된다 -> item 테이블의 id 칼럼값이 stock 테이블의 item_id 칼럼에 존재하지 않는 경우들 -> LEFT OUTER JOIN을 했기 때문에 왼쪽에 있는 item 테이블 기줕으로 테이블이 조인되었기 때문

ex)
SELECT
    item.id
    item.name
    stock.item_id
    stock.inventory_count
FROM item RIGHT OUTER JOIN stock
ON item.id = stock.item_id

* RIGHT OUTER JOIN -> 오른쪽의 stock 테이블 기준으로 테이블이 합쳐진다
* 이 경우 NULL 값이 있는 로우가 없어졌다 -> stock 테이블을 기준으로 하기 때문이다 -> stock 테이블의 모든 item_id 칼럼 값은 item 테이블의 id 칼럼에 존재하기 때문

조인할 때 테이블에 alias 붙이기

ex)
SELECT
    i.id
    i.name
    s.item_id
    s.inventory_count
FROM item AS i LEFT OUTER JOIN stock AS s
ON i.id = s.item_id;

* AS 를 스킵해도 된다
----------------------------------------------------------------------------------------------------------------------

SQL 문 안에서 우리는

컬럼 이름에도 alias를 붙일 수 있고, 

테이블 이름에도 alias를 붙일 수 있습니다.

그리고 둘다 원래 이름 뒤에 AS를 쓰거나, 스페이스 하나를 띄우고 그 뒤에 alias를 쓰면 된다는 점이 같은데요. 

하지만 두 종류의 alias는 약간의 용도 차이가 있습니다. 

일단 컬럼의 alias는 각 컬럼 이름이 실제로 우리에게 그 alias로 변환되어서 보여지게 하기 위한 용도로 쓰입니다. 

이와 달리 테이블의 alias는 조회 결과에서 보기 위한 게 아니라 SQL 문의 전체 길이를 줄여서 가독성을 높이기 위해 사용됩니다. 그리고 특히 조인(join)을 할 때, 만약 서로 다른 테이블에 같은 이름의 컬럼이 존재한다면, SQL 문 안에서 그 컬럼을 가리킬 때 무슨 테이블의 컬럼인지를 더 짧게 표현해주기 위해서도 사용되구요.

예를 들어, 우리가 배운 member 테이블과 item 테이블에는 둘다 gender라는 컬럼이 있었습니다.

이때

(1) 전자는 회원의 성별을 나타내기 위한 컬럼이고,

(2) 후자는 상품이 여성용인지 남성용인지, 혹은 남녀공용인지를 나타내기 위한 컬럼인데

우연히도 컬럼 이름이 같은 건데요. 만약 SELECT 절에서 gender 컬럼을 쓰려면 어느 테이블의 컬럼인지를 쉽게 나타내기 위해 테이블에 alias를 붙여주면 좋습니다.

만약 member 테이블에 m, item 테이블에 i라는 alias를 붙였다면

(1)은 member.gender 대신 m.gender

(2)는 item.gender 대신 i.gender

라고 써주면 됩니다. 

그리고 테이블에 alias를 붙였을 때는 주의할 점이 하나 있습니다.

우리는 FROM 절에서 테이블에 alias를 붙이는데요. 이렇게 한번 alias를 붙였으면, 다른 모든 절에서 그 테이블은 그 alias로만 나타내야 한다는 점입니다. 만약 다른 절에서 alias가 아닌 원래의 테이블 이름을 사용하면 오히려 에러가 나게 됩니다. 


컬럼의 alias와 테이블의 alias, 어떻게 쓰고, 각각 왜 필요한 건지 이제 잘 아시겠죠?
--------------------------------------------------------------------------------------------------------------------------------

INNER JOIN
* 각 테이블에서 조인 기준으로 사용된 컬럼들의 일치하는 값이 둘 다 존재하는 로우들만 합치는 조인
* 기준이 되는 테이블이 따로 없다
* stock 테이블과 item 테이블에서는 stock 테이블의 item_id 값과 item 테이블의 id 값이 일치하는 로우들만 가로로 연결한다
* 위의 예시에서 JOIN으로 인해 생기는 NULL 값을 출력하지 않기 위해 LEFT OUTER JOIN 을 할지 RIGHT OUTER JOIN을 할지 고민하지 않아도 되겠네? -> 기준 칼럼이 NULL이 되는 경우가 없다
* 집합으로 따지면 교집합!

ex)
SELECT
    i.id
    i.name
    s.item_id
    s.inventory_count
FROM item AS i INNER JOIN stock AS s
ON i.id = s.item_id;

--------------------------------------------------------------------------------------------------------------------

이전 영상에서 item 테이블과 stock 테이블을

RIGHT OUTER JOIN한 결과와 INNER JOIN한 결과가 같았습니다. 그 이유는 stock 테이블은 당연히 item 테이블에 존재하는 상품의 재고 수를 담고 있고, item 테이블에 있지 않은 엉뚱한 상품의 재고 수를 담고 있지는 않기 때문에 그랬는데요. 즉, stock 테이블의 item_id 컬럼이 item 테이블의 id 컬럼을 참조하는 Foreign Key였기 때문입니다. 이렇게 Foreign Key를 기준으로 조인하면 하나의 OUTER JOIN(LEFT 또는 RIGHT)의 결과와 INNER JOIN의 결과가 같을 수밖에 없습니다.

하지만 꼭 Foreign Key를 기준으로 조인을 해야만 하는 건 아닙니다. Foreign Key가 아닌 컬럼을 기준으로 해서 조인할 수도 있는데요. 그리고 이렇게 하면 보통

(1) LEFT OUTER JOIN 

(2) RIGHT OUTER JOIN

(3) INNER JOIN 

세 가지 조인의 결과가 모두 달라집니다.

잠깐 다음 두 테이블을 볼까요?

지금 왼쪽의 player 테이블은 축구 선수의 이름과 그 소속팀을 나타내는 테이블이고, 오른쪽의 team 테이블은 각 축구팀이 어느 지역에 속하는지를 나타내는 테이블입니다. 지금 player 테이블의 team 컬럼과 team 테이블의 team_name 컬럼이 서로 연관된 컬럼이라는 게 한 눈에 보이네요.

하지만 player 테이블의 team 컬럼의 값이 반드시 team 테이블의 team_name 컬럼에 존재하는 것은 아닙니다. 지금 보면 dragons, tigers, runaway_team, freestyle이라는 팀은 team 테이블에 없습니다. 그러니까 두 테이블 사이에는 Foreign Key 관계가 없는 겁니다. 그래도 조인은 할 수 있는데요. 

Workbench에서 각 테이블의 모습은 다음과 같습니다.

player 테이블

team 테이블

player 테이블의 team 컬럼과, team 테이블의 team_name 컬럼을 기준으로 해서 두 테이블로 이때까지 배운 3가지 조인을 해보겠습니다.
1. LEFT OUTER JOIN

결과를 보니 지금 선수들의 소속팀 중에 아직 지역 정보가 없는 팀들도 있네요. 지금 SELECT 절 뒤의 컬럼 순서는 여러분의 이해를 돕기 위해 제가 적절하게 조정했습니다.
2. RIGHT OUTER JOIN

지금 superkick이라는 팀에 속한 선수가 2명 있습니다. 그리고 아직 그 소속 선수들의 정보가 player 테이블에 없는 팀도 있네요.
3. INNER JOIN

선수 정보와 팀 정보가 둘다 존재하는 것들이 잘 조회됩니다. 위의 두 OUTER JOIN과는 전혀 다른 결과죠?

자, 정리해볼게요.

이전 영상에서 item 테이블과 stock 테이블을 조인할 때는 RIGHT OUTER JOIN과 INNER JOIN의 결과가 같았지만, 지금 player 테이블과 team 테이블을 조인할 때는 결과가 다르죠?

다시 한번 말하자면, 이전 영상의

stock 테이블의 경우 그 item_id 컬럼이 item 테이블의 id 컬럼을 참조하는 Foreign Key(외래키)였습니다. 즉, item_id 컬럼의 값이 id 컬럼에 반드시 존재할 수밖에 없는 관계였죠.

하지만 player 테이블의 team 컬럼과 team 테이블의 team_name 컬럼은 그런 관계는 아니었구요.

조인을 할 때 보통 Foreign Key를 기준으로 하는 것은 맞지만, 그렇다고 꼭 Foreign Key만을 기준으로 해야하는 것은 아닙니다. 방금처럼 꼭 Foreign Key가 존재하지 않더라도 서로 같은 의미를 나타내는 컬럼들(team 컬럼, team_name 컬럼)을 기준으로 조인하기도 하죠.

꼭 Foreign Key가 아니더라도 서로 연관있는 컬럼을 기준으로 조인을 하는 경우도 많습니다. 이 사실을 꼭 기억하세요.
---------------------------------------------------------------------------------------------------------------------------------

이때까지

(1) LEFT OUTER JOIN / RIHGT OUTER JOIN 

(2) INNER JOIN

을 배웠습니다.

하지만 이것들은 테이블을 합치는 작업의 일부분에 불과합니다. 이번 노트에서는 테이블을 합치는 작업들을 좀더 체계적인 관점에서 배워보겠습니다.

이 노트의 내용을 제대로 이해한다면 여러분의 SQL 사용 능력은 한층 업그레이드될 겁니다. 잘 집중해주세요.

테이블을 합치는 작업을 앞으로 '연산'이라고 표현하겠습니다. 자, 시작해볼게요.

테이블을 합치는 연산은 크게 결합 연산과 집합 연산으로 나눌 수 있습니다.

결합 연산은 테이블을 가로 방향으로 합치는 것에 관한 연산이고,

집합 연산은 테이블을 세로 방향으로 합치는 것에 관한 연산입니다.

그럼 우리가 배운 조인은 이 둘 중 무엇에 해당할까요? 조인은 결합 연산에 해당합니다. 조인의 과정을 하나씩 생각해보세요.

조인은 두 테이블의 각 컬럼을 기준으로 해서 같은 값을 가진 row들을 가로 방향으로 이어붙이는 작업이었죠? 따라서 조인은 결합 연산에 해당합니다.

그렇다면 테이블을 세로 방향으로 합치는 것에 관한 연산인 집합 연산은 뭘까요? 

여러분이 학교에서 수학 시간에 배웠던 집합 개념을 잠깐 떠올려보세요.

아래와 같은 그림을 그려가며 배웠던 적이 있었을 텐데요.

이 그림과 같은 A 집합, B 집합이 있다고 할 때

    c 를 A와 B의 교집합 : A ∩ B
    a 를 A의 차집합 : A - B
    b 를 B의 차집합 : B - A
    (a+b+c) 를 A와 B의 합집합 : A U B

이라는 것을 배우셨을 겁니다.

집합 연산은 테이블 하나를 집합 하나로 보고, 그 안의 각 row를 하나의 원소로 간주하고 진행되는 연산입니다. 예시를 통해 이해해볼게요.

자, 이제 다음과 같이 '회원 정보를 담은 member 테이블' 두 개가 있다고 해봅시다. 

 

두 테이블은 컬럼 구조가 같습니다. 그러니까 두 테이블은 같은 종류의 테이블이라고 할 수 있습니다.

자, 중요한 사실 하나를 알려드릴게요. 집합 연산은 같은 종류의 테이블들끼리만 가능합니다. 

왜 그럴까요? 테이블의 row 하나하나를 집합에서 말하는 하나의 원소라고 생각해보세요. 만약 같은 종류의 테이블이 아니면 row의 컬럼 구조가 다르기 때문에 각 원소가 서로 동질한 원소라고 할 수 없고, 그럼 애초에 집합 연산을 수행할 수 없습니다.

지금

member_A 테이블을 A 집합, member_B 테이블을 B 집합이라고 생각했을 때, 집합 관점에서 각 영역을 표현하면 다음과 같습니다.
(1) A ∩ B

(2) A - B

(3) B - A


(4) A U B

각 영역의 결과가 왜 위와 같이 표현되는지 이해되시나요? 방금 전에 말했듯이 두 테이블의 각 row를 하나의 원소로 보고 생각하면 이해하기 쉽습니다.

SQL에서도 이런 집합 연산이 가능합니다. 바로 이런 식으로 말이죠.
(1) A ∩ B (INTERSECT 연산자 사용)

SELECT * FROM member_A 

INTERSECT 

SELECT * FROM member_B
(2) A - B (MINUS 연산자 또는 EXCEPT 연산자 사용)

SELECT * FROM member_A 

MINUS

SELECT * FROM member_B
(3) B - A (MINUS 연산자 또는 EXCEPT 연산자 사용)

SELECT * FROM member_B

MINUS

SELECT * FROM member_A
(4) A U B (UNION 연산자 사용)

SELECT * FROM member_A

UNION

SELECT * FROM member_B

(*합집합을 나타낼 때, 두 집합이 공통적으로 갖고 있는 원소(교집합에 속하는 원소들)는 중복을 제거하고 하나만 표시됩니다. 같은 원리로 UNION 연산자도 두 테이블에 공통적으로 존재하는 row는 하나만 결과에 표시하는데요. 다음 영상과 노트에서 한 번 더 나오는 내용이니까 잘 기억해두세요)  

이런 식으로 두 테이블 간에 집합 연산을 할 수 있고 그 결과는 각각 위에서 본 그림과 같습니다.

하지만 안타까운 점이 하나 있습니다. 그건 바로 위의 3가지 집합 연산자들(INTERSECT, MINUS, UNION) 중에서 MySQL에서는 버전 8.0 기준으로 UNION 연산자만 지원한다는 점인데요.(다른 DBMS인 오라클에서는 3가지 연산자 모두를 지원합니다.)

그럼 MySQL에서는 INTERSECT, MINUS 연산은 포기해야하는 걸까요? 비록 이런 집합 연산자를 바로 사용할 수는 없지만 우리가 배운, 결합 연산에 해당하는 조인을 사용해서 간접적으로 원하는 결과를 얻을 수 있는데요. 그 방법을 다음 영상에서 살펴보겠습니다.

그 전에 일단 여러분께서는 이 노트의 내용을 완벽하게 이해해주세요!
----------------------------------------------------------------------------------------------------------------------
